import Mathlib.Data.Real.Basic
import Mathlib.Algebra.Order.AbsoluteValue
import Mathlib.Data.ENat.Basic
import Mathlib.Data.Real.ENNReal
import Mathlib.Topology.MetricSpace.Basic

-- set_option trace.Meta.synthInstance true
example : InfSet (Filter Î±) := inferInstance

example (f : Î± â†’ Î²) (g : Î² â†’ Î³) (a : Filter Î±) (b : Filter Î²) (c : Filter Î³) 
  (hf : Filter.Tendsto f a b) (hg : Filter.Tendsto g b c) : Filter.Tendsto (g âˆ˜ f) a c := by
    intro z hz
    -- show g â»Â¹' z âˆˆ Filter.map f a
    exact hf $ hg hz


open scoped ENNReal NNReal

section
  variable {E} [EMetricSpace E]
  namespace EMetricSpace
  abbrev Set := _root_.Set

  def openBall (center : E) (radius : â„â‰¥0âˆž) := EMetric.ball center radius

  def closedBall (center : E) (radius : â„â‰¥0âˆž) := { x : E | edist x center â‰¤ radius }

  def sphere (center : E) (radius : â„â‰¥0âˆž) := { x : E | edist x center = radius }

  def Set.interior (s : Set E) := { c : E | âˆƒ r > 0, openBall c r âŠ† s }

  def Set.IsOpen (s : Set E) := s âŠ† s.interior

  def Set.closure (s : Set E) := { c : E | âˆ€ r > 0, (openBall c r âˆ© s).Nonempty }

  def Set.IsClosed (s : Set E) := s.closure âŠ† s

  def neighborhood (x : E) := { s : Set E | x âˆˆ s.interior }
  
  def ð“ (x : E) : Filter E where
    sets := { s : Set E | x âˆˆ s.interior }
    univ_sets := by
      use 1
      simp
    sets_of_superset := by
      intro X Y âŸ¨r, hrâŸ© hXY
      use r
      constructor
      . exact hr.1
      . intro z hz
        exact hXY $ hr.2 hz
    inter_sets := by
      intro X Y âŸ¨r, hrâŸ© âŸ¨s, hsâŸ©
      let t := min r s
      use t
      sorry


  def Set.clusterPoint (s : Set E) := { x : E | x âˆˆ (s \ {x}).closure }

  def Set.isolatedPoint (s : Set E) := { x âˆˆ s | x âˆ‰ (s \ {x}).closure }

  theorem Set.openBall.center_mem (c : E) (r : â„â‰¥0âˆž) (rp : r > 0) : c âˆˆ openBall c r :=
    show edist .. < _ from edist_self c â–¸ rp

  theorem Set.sub_closure (s : Set E) : s âŠ† s.closure :=
    Î» x hx r rp => âŸ¨x, âŸ¨openBall.center_mem x r rp, hxâŸ©âŸ©

  theorem Set.IsClosed.closure_eq {s : Set E} (hs : s.IsClosed) : s.closure = s :=
    Set.eq_of_subset_of_subset hs s.sub_closure

  theorem Set.interior_sub (s : Set E) : s.interior âŠ† s :=
    Î» x âŸ¨r, rp, hxsâŸ© => hxs (openBall.center_mem x r rp)

  theorem Set.IsOpen.interior_eq {s : Set E} (hs : s.IsOpen) : s.interior = s :=
    Set.eq_of_subset_of_subset s.interior_sub hs

  theorem Set.interior_compl (s : Set E) : s.interiorá¶œ = sá¶œ.closure := by
    ext c
    show (Â¬âˆƒ _, _) â†” âˆ€ _, _
    push_neg
    rw [forall_congr']
    intro x
    rw [imp_congr_right]
    intro _
    rw [Set.not_subset]
    rfl

  theorem Set.isOpen_iff_compl_isClosed (s : Set E) : s.IsOpen â†” sá¶œ.IsClosed := by
    dsimp [IsOpen, IsClosed]
    rw [â†Set.compl_subset_compl, interior_compl]


  -- converse is false
  theorem Set.interior_unionâ‚›_sub (c : Set (Set E)) : â‹ƒâ‚€ c.image interior âŠ† Set.interior (â‹ƒâ‚€ c) := by
    intro x âŸ¨sâ‚’, âŸ¨âŸ¨s, hs, hsâ‚€âŸ©, hxsâŸ©âŸ©
    rw [â†hsâ‚€] at hxs
    let âŸ¨r, rp, hrâŸ© := hxs
    use r
    constructor
    . exact rp
    . intro y hy
      use s
      constructor
      . exact hs
      . exact hr hy

  -- converse is true in the finite case
  theorem Set.interâ‚›_interior_sub (c : Set (Set E)) : Set.interior (â‹‚â‚€ c) âŠ† â‹‚â‚€ c.image interior := by
    intro x âŸ¨r, rp, hrâŸ©
    intro sâ‚’ âŸ¨s, hs, hsâ‚’âŸ©
    rw [â†hsâ‚’]
    use r
    constructor
    . exact rp
    . intro y hy
      exact hr hy _ hs

  theorem Set.interior_inter_sub (sâ‚ sâ‚‚ : Set E) : sâ‚.interior âˆ© sâ‚‚.interior âŠ† (sâ‚ âˆ© sâ‚‚).interior := by
    intro x âŸ¨âŸ¨râ‚, rpâ‚, hâ‚âŸ©, âŸ¨râ‚‚, rpâ‚‚, hâ‚‚âŸ©âŸ©
    -- let r := min râ‚ râ‚‚
    sorry

  -- converse is false
  theorem Set.interâ‚›_closure_sub (c : Set (Set E)) : Set.closure (â‹‚â‚€ c) âŠ† â‹‚â‚€ c.image closure := by
    intro x hx 
    intro s_bar âŸ¨s, hsâŸ© 
    rw [â†hs.2]
    intro r rp
    let âŸ¨y, hyâŸ© := hx r rp
    use y
    constructor
    . exact hy.1
    . exact hy.2 s hs.1

  -- theorem Set.IsOpenUnionâ‚› (c : Set (Set E)) (h : âˆ€ s âˆˆ c, s.IsOpen) : IsOpen (â‹ƒâ‚€ c) := 
  --   flip subset_trans c.interior_unionâ‚›_sub $ Set.unionâ‚›_subset_unionâ‚› Î» s hs => âŸ¨s, âŸ¨hs, (h s hs).interior_eqâŸ©âŸ©

  -- theorem Set.IsClosedInterâ‚› (c : Set (Set E)) (h : âˆ€ s âˆˆ c, s.IsClosed) : IsClosed (â‹‚â‚€ c) := 
  --   c.interâ‚›_closure_sub.trans $ Set.interâ‚›_subset_interâ‚› Î» s hs => âŸ¨s, âŸ¨hs, (h s hs).closure_eqâŸ©âŸ©


  def Function.TendsTo {E F} [EMetricSpace E] [EMetricSpace F] (f : E â†’ F) (a : E) (l : F) := 
    âˆ€ V âˆˆ neighborhood l, âˆƒ U âˆˆ neighborhood a, U.image f âŠ† V

  end EMetricSpace
end
